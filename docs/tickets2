================================================================================
PW-030: Wizard zu Kalender - falsche Fächer und Blocks (trotz VWL Setting)
================================================================================
STATUS: OFFEN
TYP: Bug
PRIORITÄT: P0

PROBLEM:
Im Lernplan Wizard tauchen Blocks wie Rechtsgebiet und URG auf, obwohl in den
User Settings als Studienfach VWL eingestellt ist. Im Kalender werden Themen
zwar weitergeleitet und erhalten die richtige Rechtsgebiet Farbe, aber die
Auswahl im Wizard scheint nicht aus den User Settings Fächerlisten zu kommen,
sondern aus einem Default oder einem alten Zustand.

SOLL-ZUSTAND:
Wizard und Kalender nutzen konsistent dieselbe Quelle für Fächer und Block-Typen.
Wenn Studienfach VWL eingestellt ist, dürfen im Wizard keine juristischen
Default-Fächer wie Rechtsgebiet oder URG erscheinen, sondern nur die Fächer
aus den User Settings.

ROOT CAUSE (VERIFIZIERT):
Lage: src/features/lernplan-wizard/steps/step-7-urg-mode.jsx, Zeilen 92-115

```javascript
// Zeile 95-96: HARDCODED DEFAULT
const DEFAULT_RECHTSGEBIETE = ['zivilrecht', 'oeffentliches-recht', 'strafrecht'];

// Zeile 98-106: Versucht, User Settings zu lesen
try {
  const savedSettings = localStorage.getItem(SETTINGS_KEY);
  if (savedSettings) {
    const settings = JSON.parse(savedSettings);
    const userRechtsgebiete = settings?.jura?.selectedRechtsgebiete;  // ← PROBLEM
    // ...
  }
} catch (e) { ... }

// Zeile 113: FALLBACK ZU HARDCODED DEFAULTS
updateWizardData({ selectedRechtsgebiete: DEFAULT_RECHTSGEBIETE });
```

PROBLEME:
1. Falscher Settings-Pfad: Code sucht nach `settings.jura.selectedRechtsgebiete`
2. Keine Alternative: Kein user-settings-context.jsx oder Supabase-Integration
3. Hardcoded Fallback: Wenn User Settings nicht gelesen werden → IMMER juristische Fächer
4. Keine VWL-Unterstützung: Für VWL-Nutzer gibt es keine wirtschaftlichen Fächer

SCOPE-FENCE:
┌─────────────────────────────────────────────────────────────────────────────┐
│ ERLAUBT                                                                     │
├─────────────────────────────────────────────────────────────────────────────┤
│ ✅ step-7-urg-mode.jsx: DEFAULT_RECHTSGEBIETE durch User Settings ersetzen  │
│ ✅ step-7-urg-mode.jsx: Settings-Pfad korrigieren (falls falsch)            │
│ ✅ Verbindung zu korrekter Settings-Quelle herstellen                       │
├─────────────────────────────────────────────────────────────────────────────┤
│ VERBOTEN                                                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│ ❌ Refactoring von bestehenden Komponenten                                  │
│ ❌ Neue Dependencies hinzufügen                                             │
│ ❌ UI-Änderungen außerhalb des betroffenen Bereichs                         │
│ ❌ API Contracts ändern                                                     │
└─────────────────────────────────────────────────────────────────────────────┘

BETROFFENE DATEIEN:
- src/features/lernplan-wizard/steps/step-7-urg-mode.jsx (Zeile 92-115)

CHANGE-BUDGET:
- Max 1 Datei
- Max 30 geänderte Zeilen

AKZEPTANZKRITERIEN:
- [ ] Wizard lädt Fächer aus korrekter Settings-Quelle
- [ ] Bei Studienfach VWL erscheinen keine juristischen Defaults (RG, URG)
- [ ] Fallback nur wenn KEINE User Settings existieren
- [ ] Settings-Pfad ist korrekt und funktioniert

TESTPLAN:
1. User Settings → Studienfach auf "VWL" setzen
2. Wizard starten → Step 7 prüfen
3. Erwartung: Nur VWL-relevante Fächer sichtbar, keine RG/URG
4. Wizard starten OHNE User Settings → Fallback prüfen
5. Erwartung: Sinnvoller Default (nicht hardcoded Jura)


================================================================================
PW-031: Wizard zu Kalender - Aufgaben werden nicht übernommen
================================================================================
STATUS: GEFIXT
TYP: Bug
PRIORITÄT: P0

PROBLEM:
Themen werden vom Lernplan Wizard in den Kalender übernommen (inklusive
korrekter Rechtsgebiet Farbe), aber Aufgaben erscheinen im Kalender nicht
oder gehen beim Speichern verloren.

SOLL-ZUSTAND:
Aufgaben, die im Wizard zu einem Thema oder Block erfasst werden, werden
beim Erstellen des Plans korrekt persistiert und im Kalender angezeigt.

ROOT CAUSE (VERIFIZIERT):
**3 separate Probleme identifiziert:**

**Problem 1: Queue-Länge-Mismatch**
Lage: wizard-context.jsx, Zeilen 873-890
- contentQueue hat N Items, aber täglich gibt es M Blöcke
- Wenn täglich 3 Blöcke aber nur 2 Content-Items → 3. Block erhält NULL
- contentIndex++ inkrementiert für JEDEN Block, nicht alle haben Content

**Problem 2: Tasks werden NICHT separat persistiert (KRITISCH)**
Lage: calendar-context.jsx, Zeilen 361-378

```javascript
const setCalendarData = useCallback(async (newBlocks, metadata = {}) => {
  await setBlocksByDateSync(newBlocks);  // ← NUR BLOCKS, KEINE TASKS!
  await updateLernplanMetadataSync(newMetadata);
});
```

Supabase hat SEPARATE Tabellen:
- `calendar_blocks` → Blöcke (Tag, Position, Rechtsgebiet)
- `calendar_tasks` → Tasks (separate Zeilen mit dateKey FK)

Tasks sind im Wizard EMBEDDED in blocks.tasks[], aber müssen SEPARAT
in `calendar_tasks` gespeichert werden via `saveDayTasks()`.

**Problem 3: saveDayTasks() wird NIEMALS aufgerufen**
Lage: wizard-context.jsx, nach setCalendarData()

```javascript
// FEHLENDER CODE nach setCalendarData():
for (const [dateKey, dayBlocks] of Object.entries(blocks)) {
  const dayTasks = dayBlocks.flatMap(b => b.tasks || []);
  if (dayTasks.length > 0) {
    await saveDayTasks(dateKey, dayTasks);  // ← FEHLT KOMPLETT!
  }
}
```

SCOPE-FENCE:
┌─────────────────────────────────────────────────────────────────────────────┐
│ ERLAUBT                                                                     │
├─────────────────────────────────────────────────────────────────────────────┤
│ ✅ wizard-context.jsx: Nach setCalendarData() → saveDayTasks() aufrufen     │
│ ✅ wizard-context.jsx: Tasks aus blocks extrahieren und separat speichern   │
│ ✅ calendar-context.jsx: saveDayTasks im value-Objekt exponieren            │
├─────────────────────────────────────────────────────────────────────────────┤
│ VERBOTEN                                                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│ ❌ Datenstruktur ändern (Block-Format, Tasks-Format)                        │
│ ❌ Supabase Schema ändern                                                   │
│ ❌ UI-Änderungen                                                            │
│ ❌ Themen oder Farben regressieren                                          │
└─────────────────────────────────────────────────────────────────────────────┘

BETROFFENE DATEIEN:
- src/features/lernplan-wizard/context/wizard-context.jsx (completeWizard, completeManualCalendar, completeAutomaticLernplan)
- src/contexts/calendar-context.jsx (saveDayTasks exponieren falls nötig)

CHANGE-BUDGET:
- Max 2 Dateien
- Max 50 geänderte Zeilen

AKZEPTANZKRITERIEN:
- [x] Tasks werden nach Wizard-Completion in `calendar_tasks` Tabelle gespeichert
- [x] saveDayTasks() wird für jedes Datum mit Tasks aufgerufen
- [ ] Aufgaben sind nach Planerstellung im Kalender sichtbar (manuell testen)
- [ ] Aufgaben bleiben nach Reload erhalten (manuell testen)
- [x] Themen und Farben regressieren nicht

FIX IMPLEMENTIERT:
- calendar-context.jsx: `setCalendarData()` extrahiert jetzt Tasks aus blocks.tasks[]
- Für jedes Datum wird `saveDayTasks(dateKey, dayTasks)` aufgerufen
- Tasks erhalten dateKey und blockId für korrekte Persistierung

TESTPLAN:
1. Wizard starten → Thema mit 3 Aufgaben anlegen
2. Lernplan erstellen → Browser DevTools → Supabase Logs prüfen
3. Erwartung: INSERT in `calendar_tasks` sichtbar
4. Kalender öffnen → Block anklicken → Aufgaben prüfen
5. Erwartung: Alle 3 Aufgaben sichtbar
6. Seite neu laden → Aufgaben erneut prüfen
7. Erwartung: Aufgaben sind noch da (aus Supabase geladen)


================================================================================
PW-212: Themenliste Titel-Workflow & URG-Auto-Matching
================================================================================
STATUS: OFFEN
TYP: Feature / UX
PRIORITÄT: P2

PROBLEM:
- Ist: Themenlisten haben kein Titel-Feld. Der Header zeigt nur selectedAreas
  (vordefinierte URGs/Fächer) als große Überschrift. OCR-extrahierte Fachnamen
  wie "Grundlagen des Wirtschaftsverwaltungsrechts" können nirgends dargestellt
  werden, weil sie keine vordefinierten URGs sind. Beim Speichern bekommt die
  Themenliste einen Auto-Namen aus selectedAreas, aber der User hat keine
  Kontrolle über den Titel.
- Soll: Jede Themenliste bekommt ein editierbares Titel-Feld (über dem URG-
  Autocomplete). Beim Speichern öffnet sich ein Dialog mit einem auto-
  generierten Titel (Semester + Jahr + Fach), den der User bearbeiten kann.
  Bei Screenshot-Uploads wird der OCR-erkannte Fachname als Titel vorgeschlagen.
  Wenn der OCR-Fachname mit einem existierenden URG/Fach matcht, wird es
  automatisch in selectedAreas eingetragen.
- Kontext: Themenlisten-Editor, Screenshot-Upload (PW-211)

HINTERGRUND:
Die aktuelle Architektur kennt zwei Datenquellen für "Fächer":
1. Jura-Mode: URGs aus `unterrechtsgebiete-data.js` (~50 Einträge wie
   "Staatsorganisationsrecht", "Grundrechte", "Sachenrecht")
2. Nicht-Jura-Mode: Benutzerdefinierte Fächer aus User-Settings (z.B.
   "Anatomie", "Biochemie", "Rechnungswesen")

Der OCR-extrahierte Fachname (z.B. "Wirtschaftsverwaltungsrecht") ist ein
Kurs-/Vorlesungstitel und existiert typischerweise NICHT als URG. Diese
Namen sind wertvolle Kontextinformation und müssen im Titel angezeigt werden.

In seltenen Fällen kann ein OCR-Fachname mit einem URG übereinstimmen
(z.B. "Grundrechte" → URG "grundrechte"). In diesen Fällen soll das
URG automatisch zu selectedAreas hinzugefügt werden.

ARCHITEKTUR-ÄNDERUNG:
```
Aktuell:
┌─────────────────────────────────────┐
│  [URG Autocomplete - selectedAreas] │  ← Nur vordefinierte URGs
│  "Beschreibung des Lernplans"       │
└─────────────────────────────────────┘

Neu:
┌─────────────────────────────────────┐
│  "WS 24/25 - Wirtschaftsrecht"     │  ← Editierbarer Titel (contentPlan.name)
│  [URG zuordnen...]                  │  ← selectedAreas (optional)
│  "Beschreibung"                     │
└─────────────────────────────────────┘
```

Datenmodell contentPlan:
- name (string) → Titel, editierbar, im Header über URG-Autocomplete
- selectedAreas (array) → URG-Zuordnung, für Farben/Filter
- description (string) → Beschreibung, wie bisher

FEATURE 1: EDITIERBARER TITEL IM HEADER
- Neues Titel-Feld über dem AreaAutocompleteInput
- Inline-editierbar (Click-to-edit wie description)
- Groß dargestellt (text-4xl oder text-5xl)
- Nutzt contentPlan.name
- Wenn leer: Placeholder "Titel eingeben..."
- Wenn selectedAreas vorhanden UND kein Titel: wie bisher (selectedAreas als Überschrift)

FEATURE 2: SPEICHERN-DIALOG MIT TITELVORSCHLAG
- Wenn User auf "Fertig" (✓) klickt → neuer Dialog öffnet sich
- Auto-generierter Titel-Vorschlag:
  a) Screenshot-Upload: OCR-Fachname (z.B. "Grundlagen des Wirtschaftsverwaltungsrechts")
  b) Manuell erstellt: "[Semester] [Jahr] - [selectedAreas]"
     Beispiel: "WS 2024/25 - Sachenrecht, Schuldrecht"
  c) Fallback: selectedAreas als kommaseparierter String
- User kann Titel bearbeiten vor dem Speichern
- Buttons: "Abbrechen" | "Speichern"

FEATURE 3: OCR-FACH → URG/FACH MATCHING
- Beim Screenshot-Import: OCR-fach gegen bestehende URGs/Fächer matchen
- Matching-Logik unterscheidet sich je nach Modus:

  JURA-MODUS (isJura = true):
  - Datenquelle: getAllUnterrechtsgebieteFlat() (~50 URGs)
  - Matching: NUR exakter Name-Match (case-insensitive)
  - Grund: URGs sind spezifische Teilrechtsgebiete (z.B. "Grundrechte"),
    OCR-Fachnamen sind Kurs-Titel (z.B. "Wirtschaftsverwaltungsrecht").
    Ein Kurs kann mehrere URGs abdecken → contains wäre zu ungenau.
  - Beispiele:
    "Grundrechte" === "Grundrechte"              → ✓ exakt → zu selectedAreas
    "Wirtschaftsverwaltungsrecht" === ???         → ✗ kein URG → nur Titel
    "Allgemeines Schuldrecht" === "Allg. Schuldr" → ✗ kein exakter Match

  NICHT-JURA-MODUS (isJura = false):
  - Datenquelle: getAllSubjects(false) (benutzerdefinierte Fächer aus Settings)
  - Matching: Contains-Match (case-insensitive)
  - Grund: Benutzerdefinierte Fächer sind breiter (z.B. "BWL", "Anatomie"),
    OCR-Fachnamen sind Varianten davon (z.B. "Grundlagen der BWL").
    Contains ist hier sinnvoll weil die Fach-Namen kürzer und generischer sind.
  - Beispiele:
    "Anatomie I".includes("Anatomie")            → ✓ Match → zu selectedAreas
    "Grundlagen der BWL".includes("BWL")         → ✓ Match → zu selectedAreas
    "Mikroökonomie II".includes("Mikroökonomie") → ✓ Match → zu selectedAreas
    "Quantum Computing".includes(???)            → ✗ kein Fach → nur Titel
  - Sicherheit: Nur matchen wenn Fach-Name mindestens 3 Zeichen lang ist
    (verhindert versehentliche Matches bei sehr kurzen Fachnamen)

- In BEIDEN Modi:
  - Wenn Match gefunden → automatisch zu selectedAreas hinzufügen
  - OCR-Fachname wird IMMER als Titel (contentPlan.name) gesetzt
  - Beides kann vorkommen: Titel + gematchtes URG/Fach
  - Ergebnis ist immer editierbar (User hat letzte Kontrolle)

SCOPE-FENCE:
┌─────────────────────────────────────────────────────────────────────────────┐
│ ERLAUBT                                                                     │
├─────────────────────────────────────────────────────────────────────────────┤
│ ✅ themenliste-header.jsx: Titel-Feld über AreaAutocompleteInput einfügen  │
│ ✅ themenliste-editor.jsx: planName Prop an Header, Save-Dialog-Logik       │
│ ✅ themenliste-editor.jsx: handleScreenshotAccept URG-Matching einbauen     │
│ ✅ Neuer Dialog-Komponent: save-title-dialog.jsx (in features/themenliste)  │
│ ✅ themenliste-header.jsx: planName als Fallback-Titel rendern             │
├─────────────────────────────────────────────────────────────────────────────┤
│ VERBOTEN                                                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│ ❌ Supabase Schema ändern (name-Feld existiert bereits in content_plans)    │
│ ❌ URG-Datenstruktur ändern (unterrechtsgebiete-data.js)                    │
│ ❌ AreaAutocompleteInput grundlegend refactoren                             │
│ ❌ Andere Seiten (Dashboard, Kalender) anfassen                             │
│ ❌ Edge Function (super-processor) ändern                                   │
└─────────────────────────────────────────────────────────────────────────────┘

BETROFFENE DATEIEN:
- src/features/themenliste/components/themenliste-header.jsx (Titel-Feld)
- src/pages/themenliste-editor.jsx (Save-Dialog, URG-Matching, planName Prop)
- src/features/themenliste/components/save-title-dialog.jsx (NEU)
- src/features/themenliste/components/screenshot-upload-dialog.jsx (ggf. Minor)

CHANGE-BUDGET:
- Max 4 Dateien (1 neu, 3 bestehend)
- Max 200 Zeilen neu, max 50 Zeilen geändert

AKZEPTANZKRITERIEN:
- [ ] Titel-Feld ist im Header sichtbar, über dem URG-Autocomplete
- [ ] Titel ist inline-editierbar (Click-to-edit)
- [ ] Beim Klick auf "Fertig" öffnet sich ein Speichern-Dialog mit Titelvorschlag
- [ ] Screenshot-Upload: OCR-Fachname erscheint als Titel im Speichern-Dialog
- [ ] Screenshot-Upload: Wenn Fachname exakt einem URG/Fach entspricht,
      wird es automatisch zu selectedAreas hinzugefügt
- [ ] Manuell: Auto-Titel aus Semester + selectedAreas wird vorgeschlagen
- [ ] User kann Titel im Dialog bearbeiten bevor gespeichert wird
- [ ] Titel wird in contentPlan.name persistiert (Supabase content_plans.name)
- [ ] Bestehende Themenlisten ohne Titel funktionieren weiterhin (Fallback)
- [ ] Nicht-Jura: Fachname kann der gesamte Kursname sein → wird als Titel übernommen

TESTPLAN:
1. Neue Themenliste erstellen → Titel-Feld sollte leer sein, Placeholder sichtbar
2. Titel eintippen → Inline-Editing funktioniert
3. URG hinzufügen → URG unter dem Titel sichtbar
4. "Fertig" klicken → Speichern-Dialog öffnet sich
5. Erwartung: Auto-Titel aus Semester + URG(s)
6. Screenshot-Upload → Fachname "Grundlagen des Wirtschaftsverwaltungsrechts"
7. "Übernehmen" → Titel wird auf Fachname gesetzt
8. Screenshot-Upload → Fachname "Grundrechte" (existiert als URG)
9. "Übernehmen" → URG "Grundrechte" wird zu selectedAreas hinzugefügt UND Titel gesetzt
10. Bestehende Themenliste öffnen (ohne Titel) → Kein Crash, Fallback funktioniert


================================================================================
PW-213: Aufgaben-Priorität: Falscher Default und Anzeige-Zyklus
================================================================================
STATUS: OFFEN
TYP: Bug
PRIORITÄT: P1

PROBLEM:
- Ist: Neue Aufgaben werden mit falscher Priorität erstellt/angezeigt. Bei
  priority 'none' wird trotzdem ein Ausrufezeichen angezeigt. Der Klick-Zyklus
  funktioniert nicht wie erwartet (none → ! → !! → none).
- Soll: Neue Aufgaben haben keine Priorität (keine Ausrufezeichen). Der
  Klick-Zyklus ist: keine → ! (medium) → !! (high) → keine (none).
- Kontext: Dashboard Session-Widget (Themenliste-Ansicht), Aufgaben-Verwaltung

ROOT CAUSE (VERIFIZIERT):

**Problem 1: Falsche Anzeige-Logik**
Lage: src/components/dashboard/session-widget.jsx, Zeile 847

```javascript
{(aufgabe.priority || 'none') === 'none' ? '!' : aufgabe.priority === 'medium' ? '!' : '!!'}
```

Bei 'none' wird fälschlicherweise '!' angezeigt. Soll: Bei 'none' kein Symbol.

**Problem 2: Falscher Default in Aufgaben-Verwaltung**
Lage: src/components/verwaltung/aufgaben-content.jsx, Zeilen 85 und 229

```javascript
const [newTask, setNewTask] = useState({
  ...
  priority: 'medium',  // ← FALSCH, sollte 'none' sein
  ...
});
```

**Problem 3: Fehlender priority Default bei addAufgabeToPlan**
Lage: src/contexts/calendar-context.jsx, Zeilen 2453-2457

```javascript
const newAufgabe = {
  id: generateId(),
  title: aufgabeData.title || '',
  completed: false,
  // ← priority fehlt komplett!
};
```

SCOPE-FENCE:
┌─────────────────────────────────────────────────────────────────────────────┐
│ ERLAUBT                                                                     │
├─────────────────────────────────────────────────────────────────────────────┤
│ ✅ session-widget.jsx: Anzeige-Logik Zeile 847 korrigieren                  │
│ ✅ aufgaben-content.jsx: Default priority auf 'none' ändern (Z. 85, 229)    │
│ ✅ calendar-context.jsx: priority: 'none' in addAufgabeToPlan hinzufügen    │
├─────────────────────────────────────────────────────────────────────────────┤
│ VERBOTEN                                                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│ ❌ Refactoring von bestehenden Komponenten                                  │
│ ❌ Neue Dependencies hinzufügen                                             │
│ ❌ UI-Änderungen außerhalb der Prioritäts-Anzeige                           │
│ ❌ API Contracts ändern                                                     │
└─────────────────────────────────────────────────────────────────────────────┘

BETROFFENE DATEIEN:
- src/components/dashboard/session-widget.jsx (Zeile 847)
- src/components/verwaltung/aufgaben-content.jsx (Zeilen 85, 229)
- src/contexts/calendar-context.jsx (Zeilen 2453-2457)

CHANGE-BUDGET:
- Max 3 Dateien
- Max 20 geänderte Zeilen

AKZEPTANZKRITERIEN:
- [ ] Neue Aufgaben werden ohne Ausrufezeichen erstellt (priority: 'none')
- [ ] Klick-Zyklus funktioniert: keine → ! → !! → keine
- [ ] Bei priority 'none' wird kein Ausrufezeichen angezeigt
- [ ] Bestehende Aufgaben mit gesetzter Priorität funktionieren weiterhin

TESTPLAN:
1. Themenliste öffnen → neue Aufgabe hinzufügen
2. Erwartung: Kein Ausrufezeichen sichtbar
3. Auf Prioritäts-Button klicken (1x)
4. Erwartung: Ein Ausrufezeichen (!) erscheint
5. Erneut klicken (2x)
6. Erwartung: Zwei Ausrufezeichen (!!) erscheinen
7. Erneut klicken (3x)
8. Erwartung: Keine Ausrufezeichen mehr
9. Aufgaben-Verwaltung → neue Aufgabe erstellen
10. Erwartung: Priorität-Dropdown steht auf "Niedrig" (none)


================================================================================
PW-214: Aufgaben-Priority: Fehlende/inkonsistente Defaults an allen Erstellstellen
================================================================================
STATUS: OFFEN
TYP: Bug
PRIORITÄT: P1

PROBLEM:
- Ist: Aufgaben können an 10 verschiedenen Stellen im Code erstellt werden.
  Nur 2 davon haben `priority: 'none'`. 6 Stellen haben gar kein priority-Feld,
  2 Stellen (Wizard) verwenden `priority: 0` (numerisch statt string).
  Dies führt zu inkonsistentem Verhalten je nachdem, wo die Aufgabe erstellt wird.
- Soll: Alle Stellen, an denen Aufgaben erstellt werden, müssen konsistent
  `priority: 'none'` (string) als Default verwenden.
- Kontext: Aufgaben-Erstellung in verschiedenen App-Bereichen

BETROFFENE STELLEN (10 total):

┌───┬────────────────────────────────────────────────────────────┬─────────────────┐
│ # │ Datei : Zeile                                              │ Aktueller Stand │
├───┼────────────────────────────────────────────────────────────┼─────────────────┤
│ 1 │ calendar-context.jsx:1441-1447 (addTask)                   │ ❌ Kein priority│
│ 2 │ calendar-context.jsx:2453-2458 (addAufgabeToPlan)          │ ✅ 'none'       │
│ 3 │ dashboard.jsx:385-391 (handleAddBlockTask)                 │ ✅ 'none'       │
│ 4 │ themenliste-editor.jsx:773-776 (Screenshot-Import)         │ ❌ Kein priority│
│ 5 │ themenliste-editor.jsx:793-796 (Screenshot-Import Kapitel) │ ❌ Kein priority│
│ 6 │ calendar-plan-edit-card.jsx:434-438 (handleAddTask)        │ ❌ Kein priority│
│ 7 │ create-repetition-session-dialog.jsx:171-176               │ ❌ Kein priority│
│ 8 │ step-12-themen-edit-v2.jsx:399-404 (Wizard)                │ ⚠️ priority: 0  │
│ 9 │ step-12-themen-edit.jsx:214-219 (Wizard alt)               │ ⚠️ priority: 0  │
│10 │ manage-repetition-session-dialog.jsx:164-169               │ ❌ Kein priority│
└───┴────────────────────────────────────────────────────────────┴─────────────────┘

SCOPE-FENCE:
┌─────────────────────────────────────────────────────────────────────────────┐
│ ERLAUBT                                                                     │
├─────────────────────────────────────────────────────────────────────────────┤
│ ✅ Alle 8 Stellen: `priority: 'none'` hinzufügen/korrigieren               │
│ ✅ Wizard-Stellen: `priority: 0` → `priority: 'none'` ändern               │
├─────────────────────────────────────────────────────────────────────────────┤
│ VERBOTEN                                                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│ ❌ Refactoring (keine zentrale createTask-Factory o.ä.)                    │
│ ❌ Typ-Definitionen ändern                                                 │
│ ❌ UI-Änderungen                                                           │
│ ❌ Anzeige-Logik ändern (bereits in PW-213 behandelt)                      │
└─────────────────────────────────────────────────────────────────────────────┘

BETROFFENE DATEIEN:
- src/contexts/calendar-context.jsx (Zeile 1444)
- src/pages/themenliste-editor.jsx (Zeilen 775, 795)
- src/components/lernplan/calendar-plan-edit-card.jsx (Zeile 437)
- src/features/calendar/components/create-repetition-session-dialog.jsx (Zeile 175)
- src/features/lernplan-wizard/steps/step-12-themen-edit-v2.jsx (Zeile 403)
- src/features/lernplan-wizard/steps/step-12-themen-edit.jsx (Zeile 218)
- src/features/calendar/components/manage-repetition-session-dialog.jsx (Zeile 168)

CHANGE-BUDGET:
- Max 7 Dateien
- Max 15 geänderte Zeilen (je 1-2 Zeilen pro Datei)

AKZEPTANZKRITERIEN:
- [ ] Alle 10 Aufgaben-Erstellstellen haben `priority: 'none'`
- [ ] Wizard verwendet String 'none' statt numerisch 0
- [ ] Keine Regression bei bestehenden Aufgaben
- [ ] Neue Aufgaben haben überall keine Priorität (keine Ausrufezeichen)

TESTPLAN:
1. Dashboard → Block → "Neue Aufgabe" → Erwartung: Kein Ausrufezeichen
2. Themenliste-Editor → Screenshot-Upload → Erwartung: Importierte Aufgaben ohne Prio
3. Kalender → Lernplan-Block bearbeiten → Task hinzufügen → Erwartung: Kein Ausrufezeichen
4. Wiederholungs-Session erstellen → Task hinzufügen → Erwartung: Kein Ausrufezeichen
5. Wizard Step 12 → Aufgabe hinzufügen → Erwartung: Kein Ausrufezeichen
6. Bestehende Aufgaben mit Priorität prüfen → Erwartung: Priorität bleibt erhalten


================================================================================
PW-032: Mentor-Dashboard - Unrealistische Stundenzahlen in Statistiken
================================================================================
STATUS: OFFEN
TYP: Investigation / Bug
PRIORITÄT: P1

PROBLEM:
In der Mentor-Statistik-Sidebar (rechte Seite) werden extreme, unrealistische
Stundenzahlen angezeigt. Die Herkunft und Berechnung dieser Werte ist unklar.

BEOBACHTUNG:
- Sidebar zeigt Statistiken wie "Ø Lernzeit pro Tag", "Lernzeit diese Woche" etc.
- Die angezeigten Werte scheinen unrealistisch hoch zu sein

DATENFLUSS (VERIFIZIERT):
```
mentor-content.jsx (Zeile 39-46)
  ↓ useStatistics() Hook
  │
  ↓ src/hooks/useStatistics.js (Zeile 21)
  │   const { timerHistory, getTimerStats } = useTimer();
  │
  ↓ src/contexts/timer-context.jsx (Zeile 406-408)
  │   timerHistory = isAuthenticated ? supabaseHistory : localTimerHistory
  │
  ↓ Datenquellen:
  │   - LocalStorage: 'prepwell_timer_history'
  │   - Supabase: 'timer_sessions' Tabelle (duration_seconds INT)
  │
  ↓ Transformation (src/hooks/use-supabase-sync.js, Zeile 884-905):
  │   - Speichern: session.duration → duration_seconds (Sekunden)
  │   - Laden: row.duration_seconds → duration (Sekunden)
  │
  ↓ Berechnung in lernzeitStats (useStatistics.js, Zeile 49-115):
  │   - totalSeconds = sum of all session.duration
  │   - learningDays = unique dates in timerHistory
  │   - avgPerLearningDay = totalSeconds / learningDays
  │   - avgPerWeek = totalSeconds / weeks
  │   - avgPerMonth = totalSeconds / months
  │
  ↓ Sidebar-Anzeige (useStatistics.js, Zeile 1197-1286):
  │   - 'lernzeit-per-day': formatDuration(totalSeconds / learningDays)
  │   - 'lernzeit-per-week': formatDuration(thisWeekTime)
  │
  ↓ formatDuration (useStatistics.js, Zeile 543-550):
      if (seconds < 60) return Xs
      if (minutes < 60) return Xmin
      return Xh Ymin
```

CODE-ANALYSE - DURATION SPEICHERUNG:
Timer-Context speichert duration in SEKUNDEN (korrekt):
- timer-context.jsx:755 → `duration: pomodoroSettings.sessionDuration * 60`
- timer-context.jsx:767 → `duration: countdownSettings.duration * 60`
- timer-context.jsx:1005 → `actualDuration = elapsedSeconds`

Supabase Schema (supabase/schema.sql:388):
- `duration_seconds INT` - Integer für Sekunden

MÖGLICHE URSACHEN (nach Code-Analyse):

1. **Alte Daten mit falschem Format**:
   - Möglicherweise wurden in einer älteren Version Millisekunden gespeichert
   - Diese alten Einträge würden 1000x zu hohe Werte liefern
   - Beispiel: 25min = 1.500.000ms wird als 1.500.000 Sekunden gelesen = 416h

2. **Divisor-Problem bei Durchschnittsberechnung**:
   - `avgPerLearningDay = totalSeconds / learningDays`
   - Wenn `learningDays = 1`, wird ALLES durch 1 geteilt
   - Beispiel: 30h Gesamtzeit über Monate, aber nur 1 unique Date
   - → "Ø 30h pro Tag" (weil Date-Keys fehlen oder korrupt sind)

3. **Date-Parsing Bug** (useStatistics.js:57):
   ```javascript
   const learningDays = new Set(allSessions.map(s => s.date)).size;
   ```
   - Wenn `s.date` undefined/null ist → Set hat nur 1 Element (undefined)
   - → Alle Sessions werden durch 1 geteilt

4. **Wochen-Berechnung Bug** (useStatistics.js:60-64):
   ```javascript
   const weekNum = Math.ceil((date.getDate()) / 7);
   ```
   - Berechnet Wochennummer falsch (Tag des Monats / 7)
   - Kalenderwochen über Monatsgrenzen werden nicht korrekt gezählt

WAHRSCHEINLICHSTE URSACHE:
**Fehlende oder ungültige `date` Felder in timerHistory**
→ `learningDays.size = 1` → Gesamtzeit / 1 = extreme Werte

INVESTIGATIONSSCHRITTE:
1. Browser Console öffnen:
   ```javascript
   const h = JSON.parse(localStorage.getItem('prepwell_timer_history'));
   console.log('Sessions:', h?.length);
   console.log('Sample:', h?.slice(0, 3));
   console.log('Dates:', [...new Set(h?.map(s => s.date))]);
   console.log('Total duration (sek):', h?.reduce((s,x) => s + (x.duration||0), 0));
   ```

2. Prüfen:
   - Haben alle Sessions ein `date` Feld?
   - Sind die `duration` Werte plausibel? (25min = 1500, nicht 1500000)
   - Wie viele unique Dates gibt es?

3. Supabase Dashboard → timer_sessions:
   - SELECT duration_seconds, session_date FROM timer_sessions LIMIT 10;
   - Prüfen ob Werte in Sekunden sind (1500 für 25min)

RELEVANTE DATEIEN:
- src/hooks/useStatistics.js (Zeilen 49-115 - lernzeitStats)
- src/hooks/useStatistics.js (Zeilen 543-550 - formatDuration)
- src/hooks/useStatistics.js (Zeilen 1197-1286 - sidebarStats)
- src/contexts/timer-context.jsx (Zeile 406-408 - timerHistory Auswahl)
- src/contexts/timer-context.jsx (Zeilen 750-770 - Session speichern)
- src/hooks/use-supabase-sync.js (Zeilen 884-905 - DB Transformation)

AKZEPTANZKRITERIEN:
- [ ] Root Cause identifiziert
- [ ] Falls alte Daten korrupt: Migration/Cleanup durchführen
- [ ] Falls Berechnung fehlerhaft: Fix implementieren
- [ ] Angezeigte Stundenzahlen sind realistisch (1-4h/Tag, 10-30h/Woche)

TESTPLAN:
1. Console-Check (siehe INVESTIGATIONSSCHRITTE)
2. Timer starten → 1 Minute warten → Session beenden
3. Console: Neue Session prüfen → duration sollte ~60 sein
4. Mentor-Dashboard → Sidebar-Statistiken prüfen
5. Erwartung: Werte sind plausibel


================================================================================
PW-033: Code-Änderung - saveSession() Dual-Storage entfernt
================================================================================
STATUS: DURCHGEFÜHRT (29.01.2026)
TYP: Code-Änderung / Potentieller Breaking Change
PRIORITÄT: P0 - SOFORT PRÜFEN

KONTEXT:
Diese Änderung wurde als Fix für PW-032 (Duplikate in timer_sessions) durchgeführt.

================================================================================
ÄNDERUNG 1: timer-context.jsx (Zeile 564-588)
================================================================================

DATEI: src/contexts/timer-context.jsx
FUNKTION: saveSession()

VORHER (Zeile 564-587):
```javascript
// Function to save session to both localStorage and Supabase
const saveSession = useCallback((session) => {
  const sessionWithId = {
    ...session,
    id: `session-${Date.now()}`,
    savedAt: new Date().toISOString()
  };

  // Save to localStorage
  try {
    const history = loadHistoryFromStorage();
    history.push(sessionWithId);
    const trimmedHistory = history.slice(-1000);
    localStorage.setItem(HISTORY_STORAGE_KEY, JSON.stringify(trimmedHistory));
    setLocalTimerHistory(trimmedHistory);
  } catch (error) {
    console.error('Error saving timer session to localStorage:', error);
  }

  // Save to Supabase if authenticated
  if (isAuthenticated) {
    saveSessionToSupabase(sessionWithId);
  }
}, [isAuthenticated, saveSessionToSupabase]);
```

NACHHER (Zeile 564-588):
```javascript
// Function to save session to localStorage OR Supabase (not both!)
// PW-032 FIX: Saving to both caused duplicate sessions due to ID mismatch
const saveSession = useCallback((session) => {
  const sessionWithId = {
    ...session,
    id: `session-${Date.now()}`,
    savedAt: new Date().toISOString()
  };

  if (isAuthenticated) {
    // Authenticated users: Save ONLY to Supabase (prevents duplicates)
    saveSessionToSupabase(sessionWithId);
  } else {
    // Unauthenticated users: Save ONLY to localStorage
    try {
      const history = loadHistoryFromStorage();
      history.push(sessionWithId);
      const trimmedHistory = history.slice(-1000);
      localStorage.setItem(HISTORY_STORAGE_KEY, JSON.stringify(trimmedHistory));
      setLocalTimerHistory(trimmedHistory);
    } catch (error) {
      console.error('Error saving timer session to localStorage:', error);
    }
  }
}, [isAuthenticated, saveSessionToSupabase]);
```

WAS WURDE GEÄNDERT:
- VORHER: Session wurde IMMER in localStorage gespeichert UND zusätzlich in Supabase
- NACHHER: Session wird ENTWEDER in localStorage ODER in Supabase gespeichert

BEGRÜNDUNG:
- localStorage verwendet ID-Format: `session-1706123456789`
- Supabase generiert neue UUID: `abc-def-123-...`
- Bei Sync wurden IDs verglichen → keine Übereinstimmung → Duplikate hochgeladen
- Resultat: 11.000+ Duplikate in timer_sessions

POTENTIELLE PROBLEME DURCH DIESE ÄNDERUNG:

1. **Offline-Modus für eingeloggte User kaputt**:
   - VORHER: Eingeloggte User hatten localStorage als Backup
   - NACHHER: Eingeloggte User verlieren Session wenn offline
   - BETROFFEN: Timer-Session wird nicht gespeichert wenn Supabase nicht erreichbar

2. **localTimerHistory State wird nicht mehr aktualisiert**:
   - VORHER: setLocalTimerHistory() wurde immer aufgerufen
   - NACHHER: setLocalTimerHistory() nur für nicht-eingeloggte User
   - POTENTIELL BETROFFEN: UI-Komponenten die localTimerHistory verwenden

3. **Keine Migration bestehender localStorage-Daten**:
   - Bestehende Sessions in localStorage werden ignoriert (nicht gelöscht)
   - User die sich einloggen verlieren "Zugriff" auf alte localStorage-Daten

================================================================================
ÄNDERUNG 2: useStatistics.js (Zeile 59-69)
================================================================================

DATEI: src/hooks/useStatistics.js

VORHER (Zeile 59-69 existierten):
```javascript
// PW-032 DEBUG: Statistik-Werte analysieren
console.log('=== PW-032 DEBUG: lernzeitStats ===');
console.log('Sessions count:', allSessions.length);
console.log('Total seconds:', totalSeconds, '=', (totalSeconds / 3600).toFixed(2), 'h');
console.log('Unique learning days:', learningDays);
console.log('Avg per day (sek):', learningDays > 0 ? totalSeconds / learningDays : 0);
console.log('Sample sessions:', allSessions.slice(0, 3));
const suspicious = allSessions.filter(s => s.duration > 86400);
if (suspicious.length > 0) console.warn('⚠️ Sessions > 24h:', suspicious);
const missingDates = allSessions.filter(s => !s.date);
if (missingDates.length > 0) console.warn('⚠️ Sessions ohne date:', missingDates.length);
```

NACHHER:
Debug-Logs wurden komplett entfernt.

================================================================================
ROLLBACK-ANLEITUNG
================================================================================

Falls die Änderung Probleme verursacht, hier der Original-Code:

```javascript
// Function to save session to both localStorage and Supabase
const saveSession = useCallback((session) => {
  const sessionWithId = {
    ...session,
    id: `session-${Date.now()}`,
    savedAt: new Date().toISOString()
  };

  // Save to localStorage
  try {
    const history = loadHistoryFromStorage();
    history.push(sessionWithId);
    const trimmedHistory = history.slice(-1000);
    localStorage.setItem(HISTORY_STORAGE_KEY, JSON.stringify(trimmedHistory));
    setLocalTimerHistory(trimmedHistory);
  } catch (error) {
    console.error('Error saving timer session to localStorage:', error);
  }

  // Save to Supabase if authenticated
  if (isAuthenticated) {
    saveSessionToSupabase(sessionWithId);
  }
}, [isAuthenticated, saveSessionToSupabase]);
```

================================================================================
TESTPLAN
================================================================================

1. **Eingeloggt - Online:**
   - Timer starten → Session beenden
   - Erwartung: Session erscheint in Supabase timer_sessions
   - Prüfen: localStorage wurde NICHT aktualisiert

2. **Eingeloggt - Offline (Netzwerk trennen):**
   - Timer starten → Session beenden
   - Erwartung: ??? (potentiell Session verloren)

3. **Nicht eingeloggt:**
   - Timer starten → Session beenden
   - Erwartung: Session erscheint in localStorage
   - Prüfen: Supabase wurde NICHT kontaktiert

4. **UI-State nach Session:**
   - Nach Timer-Session: Wird timerHistory in UI aktualisiert?
   - Mentor-Dashboard: Zeigt neue Session an?

================================================================================
OFFENE FRAGEN
================================================================================

1. Wird saveSessionToSupabase() Fehler werfen wenn offline?
2. Gibt es Error-Handling in saveSessionToSupabase()?
3. Welche Komponenten nutzen localTimerHistory direkt?
4. Soll es einen Offline-Fallback geben?


================================================================================
PW-034: Timer-System Refactoring - Vergleich IST vs SOLL
================================================================================
STATUS: ANALYSE
TYP: Refactoring / Architektur
PRIORITÄT: P1

KONTEXT:
Das aktuelle Timer-System hat fundamentale Architekturprobleme, die zu
Duplikaten und falschen Statistiken führen (siehe PW-032, PW-033).
Dieses Ticket dokumentiert den Vergleich zwischen IST und SOLL-Zustand.

================================================================================
AKTUELLES DATENMODELL (IST)
================================================================================

TABELLE: timer_sessions (supabase/schema.sql:383-393)
```sql
CREATE TABLE timer_sessions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id),
  lernplan_id UUID REFERENCES lernplaene(id),
  session_type timer_type DEFAULT 'pomodoro',  -- enum
  duration_seconds INT,                         -- ⚠️ Sekunden, nicht ms
  completed BOOLEAN DEFAULT FALSE,
  session_date DATE,                            -- ⚠️ Nur Datum, keine Zeit
  session_time TIME,                            -- ⚠️ Separate Zeit-Spalte
  created_at TIMESTAMPTZ DEFAULT NOW()
);
```

PROBLEME MIT AKTUELLEM MODELL:

1. **Keine started_at/ended_at Timestamps**
   - Session-Start/-Ende nicht nachvollziehbar
   - Pausen können nicht berechnet werden
   - Keine Echtzeitverfolgung möglich

2. **duration_seconds manuell berechnet**
   - Frontend berechnet Dauer, nicht Backend
   - Fehleranfällig bei Browser-Throttling
   - Keine Validierung möglich

3. **Kein status Feld**
   - Keine Unterscheidung: running/completed/cancelled
   - Abgebrochene Sessions nicht erkennbar

4. **session_date + session_time getrennt**
   - Sollte ein TIMESTAMPTZ sein
   - Timezone-Probleme möglich

5. **Kein metadata Feld**
   - Pomodoro-Cycle, Phase nicht gespeichert
   - Countdown-Target nicht gespeichert

================================================================================
VORGESCHLAGENES DATENMODELL (SOLL)
================================================================================

TABELLE: timer_sessions (NEU)
```sql
CREATE TABLE timer_sessions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,

  -- Modus & Status
  mode TEXT NOT NULL CHECK (mode IN ('pomodoro', 'count_up', 'count_down', 'logbook')),
  status TEXT NOT NULL DEFAULT 'running' CHECK (status IN ('running', 'completed', 'cancelled')),

  -- Zeitstempel (WICHTIG: started_at + ended_at!)
  started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  ended_at TIMESTAMPTZ,

  -- Berechnete Dauer (beim Beenden setzen, in Millisekunden)
  duration_ms BIGINT,

  -- Kontext (optional)
  task_id UUID,
  task_title TEXT,
  source TEXT DEFAULT 'web',

  -- Flexibles Metadata für Mode-spezifische Daten
  metadata JSONB DEFAULT '{}',
  -- Beispiele:
  -- Pomodoro: {"cycle": 3, "phase": "focus", "focus_minutes": 25, "break_minutes": 5}
  -- Countdown: {"target_ms": 1800000}
  -- Logbook: {"note": "...", "manual": true}

  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Index für Statistik-Abfragen
CREATE INDEX idx_timer_sessions_user_day ON timer_sessions (user_id, DATE(started_at));
CREATE INDEX idx_timer_sessions_status ON timer_sessions (status) WHERE status = 'running';
```

================================================================================
VERGLEICH: IST vs SOLL
================================================================================

| Aspekt                  | IST (Aktuell)              | SOLL (Vorgeschlagen)       |
|-------------------------|----------------------------|----------------------------|
| Start-Zeitpunkt         | ❌ Nur created_at          | ✅ started_at              |
| End-Zeitpunkt           | ❌ Nicht vorhanden         | ✅ ended_at                |
| Dauer-Einheit           | ⚠️ Sekunden (INT)          | ✅ Millisekunden (BIGINT)  |
| Dauer-Berechnung        | ❌ Frontend                | ✅ Backend (ended-started) |
| Status                  | ❌ Nur completed Boolean   | ✅ running/completed/cancel|
| Pausen-Tracking         | ❌ Nicht möglich           | ✅ Via metadata oder events|
| Pomodoro-Phase          | ❌ Nicht gespeichert       | ✅ metadata.phase          |
| Modus-Typen             | ⚠️ Enum (pomodoro/count*)  | ✅ Inkl. logbook           |
| Timezone-Handling       | ⚠️ DATE + TIME getrennt   | ✅ TIMESTAMPTZ             |

================================================================================
AKTUELLER DATENFLUSS (PROBLEMATISCH)
================================================================================

```
Frontend (timer-context.jsx)
    │
    ├── saveSession() ─────────────────────────────────────────┐
    │   │                                                      │
    │   ├── [War: IMMER] localStorage.setItem()                │
    │   │   ID: session-{timestamp}                            │
    │   │                                                      │
    │   └── [Wenn auth] saveSessionToSupabase()                │
    │       ID: Supabase generiert UUID                        │
    │                                                          │
    └── useSupabaseSync() ─────────────────────────────────────┤
        │                                                      │
        ├── Vergleicht localStorage vs Supabase                │
        │   Problem: IDs stimmen nie überein!                  │
        │                                                      │
        └── Lädt "local-only" Items zu Supabase hoch ──────────┘
            → DUPLIKATE!

Resultat: 39.000+ Duplikate, Sync-Loop
```

================================================================================
VORGESCHLAGENER DATENFLUSS (SAUBER)
================================================================================

```
Frontend (timer-context.jsx)
    │
    ├── startTimer() ─────────────────────────────────────────┐
    │   │                                                     │
    │   └── INSERT timer_sessions (started_at=NOW, status='running')
    │       ← Returns session_id                              │
    │       → Store session_id in React state                 │
    │                                                         │
    ├── stopTimer() ──────────────────────────────────────────┤
    │   │                                                     │
    │   └── UPDATE timer_sessions                             │
    │       SET ended_at=NOW,                                 │
    │           duration_ms=EXTRACT(EPOCH FROM (ended_at-started_at))*1000,
    │           status='completed'                            │
    │       WHERE id=session_id                               │
    │                                                         │
    └── Statistik-Seite ──────────────────────────────────────┘
        │
        └── SELECT FROM daily_timer_stats (View/Aggregation)
            Keine Berechnung im Frontend nötig!
```

VORTEILE:
1. ✅ Keine Duplikate (ein INSERT pro Session)
2. ✅ Server berechnet duration (kein Frontend-Fehler)
3. ✅ Kein localStorage für Sessions (nur Supabase)
4. ✅ Statistik via Views (performant)

================================================================================
IDENTIFIZIERTE ROOT CAUSES DER AKTUELLEN PROBLEME
================================================================================

1. **Dual-Storage ohne ID-Synchronisation**
   - localStorage: `session-{timestamp}`
   - Supabase: `gen_random_uuid()`
   - Sync kann Duplikate nicht erkennen

2. **Bidirektionaler Sync**
   - useSupabaseSync lädt lokal→Supabase UND Supabase→lokal
   - Bei Löschen in Supabase: Lokale Daten werden wieder hochgeladen
   - Endlosschleife möglich

3. **Frontend berechnet Dauer**
   - Browser-Throttling verfälscht Zeiten
   - Keine Server-Validierung

4. **Keine echten Timestamps**
   - `session_date` + `session_time` statt `started_at`
   - Pausen/Unterbrechungen nicht trackbar

5. **Statistik-Berechnung im Frontend**
   - Jede Seiten-Ladung rechnet alle Sessions neu
   - Keine Aggregations-Views in Supabase

================================================================================
MIGRATION-STRATEGIE
================================================================================

PHASE 1: Schema-Update
1. Neue Spalten hinzufügen: started_at, ended_at, duration_ms, status, metadata
2. Migration: Bestehende Daten konvertieren
3. Alte Spalten (session_date, session_time, duration_seconds) deprecaten

PHASE 2: Frontend-Refactoring
1. saveSession() durch startSession() + stopSession() ersetzen
2. localStorage für timer_sessions komplett entfernen
3. useSupabaseSync für timer_sessions deaktivieren (direkter DB-Zugriff)

PHASE 3: Statistik-Optimierung
1. Supabase View: daily_timer_stats erstellen
2. Frontend: useStatistics.js vereinfachen (nur View abfragen)
3. Optional: Materialized View für Performance

================================================================================
ANTWORTEN AUF DEINE FRAGEN
================================================================================

1. **Speichert ihr aktuell Events oder nur Start/End?**
   → Aktuell: Nur End (keine Events, kein Start-Timestamp)
   → Problem: started_at fehlt komplett, nur created_at vorhanden

2. **Soll Pomodoro Pausen mitgezählt werden oder nur Fokus?**
   → Aktuell: Unklar/Inkonsistent
   → Empfehlung: Nur Fokus-Sessions speichern (Option 2 aus deinem Handbuch)

3. **Habt ihr schon mentor/mentee Zuordnung in der DB?**
   → Nein, noch nicht implementiert
   → profiles Tabelle existiert nicht in dieser Form

================================================================================
NÄCHSTE SCHRITTE
================================================================================

[ ] Entscheidung: Komplett-Refactoring oder Minimal-Fix?
[ ] Wenn Refactoring: Schema-Migration planen
[ ] Wenn Minimal-Fix: Nur Duplikat-Problem lösen (localStorage entfernen)
[ ] Bestehende Daten bereinigen (TRUNCATE timer_sessions)

================================================================================
PRIORITÄT
================================================================================

Empfehlung: Zuerst Minimal-Fix (Duplikate stoppen), dann schrittweise
Refactoring zum sauberen Modell.


================================================================================
PW-035: Timer-System Refactoring - Implementierungslücken & Fix-Plan
================================================================================
STATUS: OFFEN
TYP: Bug / Implementierungslücken
PRIORITÄT: P1

KONTEXT:
Die erste Implementierung des Timer-Refactorings (basierend auf PW-034) wurde
durchgeführt, aber bei der Überprüfung wurden mehrere Abweichungen vom Plan
und Qualitätsprobleme identifiziert. Dieses Ticket dokumentiert die Findings
und den Fix-Plan.

================================================================================
FINDINGS - ABWEICHUNGEN VOM PLAN (PW-034)
================================================================================

┌──────────┬──────────────────────────────────────────────────────────────────┐
│ SEVERITY │ FINDING                                                          │
├──────────┼──────────────────────────────────────────────────────────────────┤
│ HIGH     │ Start/Stop-Flow nicht verdrahtet                                 │
│          │ - startTimerSession/stopTimerSession werden NIRGENDWO aufgerufen│
│          │ - Stattdessen wird nur saveSession beim Abschluss genutzt       │
│          │ - Es gibt NIE "running" Sessions in der DB                      │
│          │ - Der zentrale Plan-Flow (INSERT running → UPDATE completed)    │
│          │   bleibt komplett ungenutzt                                     │
│          │ Dateien: timer-context.jsx:555, 774, 941                        │
├──────────┼──────────────────────────────────────────────────────────────────┤
│ HIGH     │ Dauerberechnung bleibt client-seitig                            │
│          │ - saveSession setzt duration_ms aus session.duration            │
│          │ - Keine serverseitige Berechnung/Validierung                    │
│          │ - Widerspricht Plan: "Backend berechnet duration"               │
│          │ Dateien: timer-context.jsx:784-799, Migration:11-15             │
├──────────┼──────────────────────────────────────────────────────────────────┤
│ MEDIUM   │ Statistiken nutzen Views nicht                                  │
│          │ - useStatistics.js basiert weiterhin auf rohem timerHistory     │
│          │ - daily_timer_stats/weekly_timer_stats Views ungenutzt          │
│          │ - Plan-Vorgabe "Statistik via View" nicht erfüllt               │
│          │ Dateien: useStatistics.js:21-55, schema.sql:409-433             │
├──────────┼──────────────────────────────────────────────────────────────────┤
│ MEDIUM   │ Schema weicht vom Soll-Modell ab                                │
│          │ - Statt mode (inkl. logbook) gibt es session_type timer_type    │
│          │ - Enum nur für pomodoro/countdown/countup                       │
│          │ - Logbuch-Sessions können nicht über timer_sessions laufen      │
│          │ Dateien: schema.sql:48, 384-399                                 │
├──────────┼──────────────────────────────────────────────────────────────────┤
│ MEDIUM   │ Offline-Sync schreibt immer status='completed'                  │
│          │ - Auch wenn Session als cancelled gespeichert wurde             │
│          │ - Verfälscht Statistik-Zahlen                                   │
│          │ Dateien: timer-context.jsx:530-541                              │
├──────────┼──────────────────────────────────────────────────────────────────┤
│ LOW      │ saveSession ignoriert session.endTime                           │
│          │ - ended_at wird immer auf "jetzt" gesetzt                       │
│          │ - Auto-Saves (Mitternacht) werden zeitlich falsch abgelegt      │
│          │ Dateien: timer-context.jsx:786-799, 952-956                     │
├──────────┼──────────────────────────────────────────────────────────────────┤
│ LOW      │ RLS erlaubt nur Self-Access                                     │
│          │ - Mentor-Access (Mentee-Sessions) aus Plan fehlt                │
│          │ Dateien: schema.sql:838-842                                     │
└──────────┴──────────────────────────────────────────────────────────────────┘

================================================================================
OFFENE FRAGEN / DESIGN-ENTSCHEIDUNGEN
================================================================================

1. Soll `logbook` wirklich in timer_sessions konsolidiert werden (Plan),
   oder bleibt das getrennt über logbuch_entries?
   → Empfehlung: Getrennt lassen (unterschiedliche Semantik)

2. Ist die Offline-Queue weiterhin gewollt, obwohl der Plan
   "kein localStorage für Sessions" vorsieht?
   → Empfehlung: Ja, für Zuverlässigkeit behalten (nur Queue, keine History)

3. Soll Mentoren-Zugriff über profiles.mentor_id implementiert werden?
   → Empfehlung: Später (separate Phase, eigenes Ticket)

================================================================================
FIX-PLAN - 5 KONKRETE ÄNDERUNGEN
================================================================================

PHASE A: Start/Stop-Flow verdrahten (HIGH Priority)
─────────────────────────────────────────────────────────────────────────────

PROBLEM: startTimerSession/stopTimerSession existieren aber werden nicht verwendet

SCOPE-FENCE:
┌─────────────────────────────────────────────────────────────────────────────┐
│ ERLAUBT                                                                     │
├─────────────────────────────────────────────────────────────────────────────┤
│ ✅ startPomodoro/startCountdown/startCountup: startTimerSession aufrufen   │
│ ✅ handleTimerComplete/stopTimer/resetTimer: stopTimerSession aufrufen     │
│ ✅ Midnight-Handler: stopTimerSession statt saveSession                    │
│ ✅ saveSession nur noch für Offline-Queue Fallback behalten                │
├─────────────────────────────────────────────────────────────────────────────┤
│ VERBOTEN                                                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│ ❌ Timer-UI ändern                                                         │
│ ❌ Neue State-Variablen hinzufügen                                         │
└─────────────────────────────────────────────────────────────────────────────┘

ÄNDERUNGEN:

1. In startPomodoro (ca. Zeile 850):
```javascript
// Nach setTimerStartedAt:
const dbSessionId = await startTimerSession({ mode: 'pomodoro' });
setCurrentDbSessionId(dbSessionId);
```

2. In startCountdown (ca. Zeile 900):
```javascript
const dbSessionId = await startTimerSession({ mode: 'countdown' });
setCurrentDbSessionId(dbSessionId);
```

3. In startCountup (ca. Zeile 930):
```javascript
const dbSessionId = await startTimerSession({ mode: 'countup' });
setCurrentDbSessionId(dbSessionId);
```

4. In handleTimerComplete (ca. Zeile 760):
```javascript
// Statt saveSession:
await stopTimerSession(currentDbSessionId, timerStartedAt, true);
```

5. In stopTimer/resetTimer:
```javascript
// Session als cancelled markieren wenn vorzeitig beendet:
await stopTimerSession(currentDbSessionId, timerStartedAt, false);
```

BETROFFENE DATEIEN:
- src/contexts/timer-context.jsx

CHANGE-BUDGET:
- Max 30 Zeilen geändert


PHASE B: Offline-Queue Status-Bug fixen (MEDIUM Priority)
─────────────────────────────────────────────────────────────────────────────

PROBLEM: syncOfflineQueue schreibt immer status='completed'

SCOPE-FENCE:
┌─────────────────────────────────────────────────────────────────────────────┐
│ ERLAUBT                                                                     │
├─────────────────────────────────────────────────────────────────────────────┤
│ ✅ syncOfflineQueue: status aus item.data.completed ableiten               │
├─────────────────────────────────────────────────────────────────────────────┤
│ VERBOTEN                                                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│ ❌ Queue-Format ändern                                                     │
└─────────────────────────────────────────────────────────────────────────────┘

ÄNDERUNG (timer-context.jsx, Zeile ~512):

```javascript
// ALT:
status: 'completed',

// NEU:
status: item.data.completed ? 'completed' : 'cancelled',
```

CHANGE-BUDGET:
- 1 Zeile


PHASE C: saveSession endTime-Bug fixen (LOW Priority)
─────────────────────────────────────────────────────────────────────────────

PROBLEM: session.endTime wird ignoriert

SCOPE-FENCE:
┌─────────────────────────────────────────────────────────────────────────────┐
│ ERLAUBT                                                                     │
├─────────────────────────────────────────────────────────────────────────────┤
│ ✅ saveSession: session.endTime verwenden wenn vorhanden                   │
├─────────────────────────────────────────────────────────────────────────────┤
│ VERBOTEN                                                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│ ❌ Neue Parameter hinzufügen                                               │
└─────────────────────────────────────────────────────────────────────────────┘

ÄNDERUNG (timer-context.jsx, Zeile ~577):

```javascript
// ALT:
const endTime = new Date();

// NEU:
const endTime = session.endTime ? new Date(session.endTime) : new Date();
```

CHANGE-BUDGET:
- 1 Zeile


PHASE D: Statistiken auf Views umstellen (MEDIUM Priority) - OPTIONAL
─────────────────────────────────────────────────────────────────────────────

PROBLEM: useStatistics.js nutzt Views nicht

HINWEIS: Diese Phase ist optional und kann später erfolgen. Die Frontend-
Berechnung funktioniert korrekt, Views wären nur Performance-Optimierung.

SCOPE-FENCE:
┌─────────────────────────────────────────────────────────────────────────────┐
│ ERLAUBT                                                                     │
├─────────────────────────────────────────────────────────────────────────────┤
│ ✅ lernzeitStats: Optional Views abfragen wenn authenticated               │
│ ✅ Fallback auf timerHistory behalten                                      │
├─────────────────────────────────────────────────────────────────────────────┤
│ VERBOTEN                                                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│ ❌ Bestehende Statistik-Logik entfernen                                    │
│ ❌ UI ändern                                                               │
└─────────────────────────────────────────────────────────────────────────────┘

BETROFFENE DATEIEN:
- src/hooks/useStatistics.js

CHANGE-BUDGET:
- Max 50 Zeilen


PHASE E: Mentor-RLS (LOW Priority) - SPÄTER
─────────────────────────────────────────────────────────────────────────────

PROBLEM: Mentor kann Mentee-Sessions nicht sehen

HINWEIS: Erfordert erst profiles.mentor_id Mapping. Eigenes Ticket.

================================================================================
REIHENFOLGE DER IMPLEMENTATION
================================================================================

1. [HIGH]   Phase A: Start/Stop-Flow verdrahten
2. [MEDIUM] Phase B: Offline-Queue Status-Bug
3. [LOW]    Phase C: saveSession endTime-Bug
4. [SPÄTER] Phase D: Views (optional)
5. [SPÄTER] Phase E: Mentor-RLS (eigenes Ticket)

================================================================================
AKZEPTANZKRITERIEN
================================================================================

Phase A:
- [ ] Timer-Start erzeugt Eintrag mit status='running' in timer_sessions
- [ ] Timer-Stop/Complete updated Eintrag mit ended_at, duration_ms, status
- [ ] Supabase Dashboard zeigt "running" Sessions während Timer läuft

Phase B:
- [ ] Offline-Queue synct cancelled Sessions mit status='cancelled'

Phase C:
- [ ] Mitternacht-Auto-Save hat korrektes ended_at (23:59:59)

================================================================================
TESTPLAN
================================================================================

1. Timer starten → Supabase prüfen → status='running', started_at gesetzt
2. Timer stoppen → Supabase prüfen → ended_at, duration_ms, status='completed'
3. Timer abbrechen → Supabase prüfen → status='cancelled'
4. Offline: Timer starten+stoppen → Online gehen → Session erscheint in DB
5. Mitternacht-Szenario: Session über Tageswechsel → Auto-Save prüfen
